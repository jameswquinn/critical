const path = require('path');
const os = require('os');
const url = require('url');
const fs = require('fs-extra');
const findUp = require('find-up');
const globby = require('globby');
const isGlob = require('is-glob');
const postcss = require("postcss");
const postcssUrl = require("postcss-url");
const rebaser = require("postcss-assets-rebase");
const Vinyl = require('vinyl');
const oust = require('oust');
const got = require('got');
const chalk = require('chalk');
const parseCssUrls = require('css-url-parser');
const tempy = require('tempy');
const slash = require('slash');
const debug = require('debug')('critical:file');
const {mapAsync, filterAsync, reduceAsync} = require('./array');
const {FileNotFoundError} = require('./errors');

const BASE_WARNING = `${chalk.yellow('Warning:')} Missing base path. Consider 'base' option. https://goo.gl/PwvFVb`;


const warn = (text, file) => process.stderr.write(`${text} ${file}${os.EOL}`);


/**
 * Fixup slashes in file paths for windows
 * @param {string} str path
 * @returns {string}
 */
function normalizePath(str) {
  return process.platform === 'win32' ? slash(str) : str;
}

/**
 * Check wether a resource is external or not
 * @param {string} href
 * @returns {boolean}
 */
function isRemote(href) {
  return /(^\/\/)|(:\/\/)/.test(href);
}

/**
 * Check wether a resource is relative or not
 * @param {string} href
 * @returns {boolean}
 */
function isRelative(href) {
  return !isRemote(href) && !path.isAbsolute(href);
}

/**
 * Wrapper for File.isVinyl to detect vinyl objects generated by gulp (vinyl < v0.5.6)
 * @param {*} file
 * @returns {string}
 */
function isVinyl(file) {
  return Vinyl.isVinyl(file) ||
    file instanceof Vinyl ||
    (file && /function File\(/.test(file.constructor.toString()) && file.contents && file.path);
}

/**
 * Check if a file exists (remote & local)
 * @param filepath
 * @param options
 * @returns {Promise<boolean>}
 */
async function fileExists(filepath, options = {}) {
  if (isVinyl(filepath)) {
    return !filepath.isNull();
  }
  if (isRemote(filepath)) {
    const {got: fetchOptions = {}} = options;
    fetchOptions.method = 'head';
    try {
      const response = await fetch(filepath, {got: fetchOptions});
      const {statusCode} = response;
      return parseInt(statusCode, 10) < 400;
    } catch (error) {
      return false;
    }
  }

  return fs.existsSync(filepath) || fs.existsSync(filepath.replace(/\?.*$/,''));
}

/**
 * Path join considering urls
 * @param {string} base
 * @param {string} part
 * @returns {*}
 */
function joinPath (base, part) {
  if (!part) {
    return base;
  }
  if (isRemote(base)) {
    return url.resolve(base, part);
  }

  return path.join(base, part.replace(/\?.*$/,''));
}

/**
 * resolve path
 * @param filepath
 * @param paths
 * @param options
 * @returns {Promise<*>}
 */
async function resolve(filepath, paths = [], options = {}) {
  let exists = await fileExists(filepath, options);
  if (exists) {
    return filepath;
  }

  for (let ref of paths) {
    const checkPath = joinPath(ref, filepath);
    exists = await fileExists(checkPath);
    if (exists) {
      return checkPath;
    }
  }

  throw new FileNotFoundError(filepath, paths);
}

/**
 *
 * @param pattern
 * @param base
 * @returns {Promise<[string]>}
 */
async function glob(pattern, {base} = {}) {
  // evaluate globs based on base path
  const patterns = Array.isArray(pattern) ? pattern : [pattern];
  // prepend base if it's not empty & not remote
  const prependBase = pattern => base && !isRemote(base) ? [path.join(base,pattern)] : [];

  return await reduceAsync(patterns, async (files, pattern) => {
    if (isGlob(pattern)) {
      const result = await globby([...prependBase(pattern), pattern]);
      return [...files, ...result];
    }

    return [...files, pattern];
  }, []);
}

/**
 * Rebase image url in css
 *
 * @param {Buffer|string} css Stylesheet
 * @param {string} from Rebase from url
 * @param {string} to Rebase to url
 * @returns {Buffer} Rebased css
 */
function rebaseAssets(css, from, to) {
  let rebased = css.toString();

  if (/\/$/.test(to)) {
    to = to + 'temp.html';
  }

  if (/\/$/.test(from)) {
    from = from + 'temp.css';
  }


  if (isRemote(from)) {
    const {pathname} = url.parse(from);
    from = pathname;
  }

  if (isRemote(to)) {

    // @todo Find a smarter solutions - JUST A QUICKFIX
    const assets = parseCssUrls(css.toString()).map(asset => ({
      search: asset,
      replace: isRemote(asset) ? asset : url.resolve(to, asset),
    }));

    rebased = assets.reduce((res, {search, replace}) => res.replace(search, replace), css.toString());
  } else if (from && to) {
    rebased = postcss().use(postcssUrl({url: "rebase"})).process(css, {from, to}).css;
  }

  return Buffer.from(rebased);
}

/**
 * Token generated by concatenating username and password with `:` character within a base64 encoded string.
 * @param  {String} user User identifier.
 * @param  {String} pass Password.
 * @returns {String} Base64 encoded authentication token.
 */
const token = (user, pass) => Buffer.from([user, pass].join(':')).toString('base64');

/**
 * Get external resource
 * @param {string} uri
 * @param {boolean} secure
 * @param {object} options Options passed to critical
 * @returns {Promise}
 */
async function fetch(uri, options = {}, secure = true) {
  const {user, pass, userAgent, got: fetchOptions = {}} = options;
  const {headers = {}, method = 'get'} = fetchOptions;
  let resourceUrl = uri;
  let protocolRelative = false;

  // Consider protocol-relative urls
  if (/^\/\//.test(uri)) {
    protocolRelative = true;
    resourceUrl = url.resolve(`http${secure ? 's' : ''}://te.st`, uri);
  }

  debug(`Fetching resource: ${resourceUrl}`);
  fetchOptions.rejectUnauthorized = false;
  if (user && pass) {
    headers.Authorization = 'Basic ' + token(user, pass);
  }
  if (userAgent) {
    headers['User-Agent'] = userAgent;
  }

  try {
    const response = await got(resourceUrl, {...fetchOptions, headers});
    if (method === 'head') {
      return response;
    }

    return Buffer.from(response.body || '');
  } catch (error) {
    if (secure && protocolRelative) {
      debug(`${error.message} - trying again over http`);
      return fetch(uri, options, false);
    }

    debug(`${resourceUrl} failed: ${error.message}`);

    if (method === 'head') {
      return error.response;
    }

    if (error.response) {
      return Buffer.from(error.response.body || '');
    }

    throw error;
  }
}

/**
 * Add stylesheet hrefs to file
 * @param {Vinyl} file vinyl file object (document)
 * @returns {*}
 */
function getStylesheetHrefs(file) {
  if (!Vinyl.isVinyl(file)) {
    throw new Error('Parameter file needs to be a vinyl object');
  }

  const stylesheets = oust.raw(file.contents.toString(), 'stylesheets');
  const preloads = oust.raw(file.contents.toString(), 'preload');

  return [...stylesheets, ...preloads]
    .filter(link => link.$el.attr('media') !== 'print' && Boolean(link.value))
    .map(link => link.value);
}

/**
 * Add asset hrefs to file
 * @param {Vinyl} file vinyl file object (stylesheet)
 * @returns {*}
 */
function getAssets(file) {
  if (!Vinyl.isVinyl(file)) {
    throw new Error('Parameter file needs to be a vinyl object');
  }

  return parseCssUrls(file.contents.toString());
}

/**
 *
 * @param {Vinyl} file the file we want to check
 * @param {object} options Critical options object
 * @returns {Promise<*>}
 */
async function getDocumentPath(file, options = {}) {
  let {base} = options;

  // check remote
  if (file.remote) {
    let {pathname} = file.urlObj;
    if (/\/$/.test(pathname)) {
      pathname += 'index.html';
    }

    return pathname;
  }

  // if we don't have a file path and
  if (!file.path) {
    return '';
  }

  if (base) {
    base = path.resolve(base);
    return `/${path.relative(base, file.path || base)}`;
  }

  // check local and assume base path based on relative stylesheets
  if (file.stylesheets) {
    const relevantRefs = file.stylesheets.filter(href => isRelative(href));

    if (relevantRefs.length === 0) {
      process.stderr.write(BASE_WARNING);

      return `/${path.relative(process.cwd(), file.path)}`;
    }

    const dots = relevantRefs.reduce((res, href) => {
      const match = /^(\.\.\/)+/.exec(href);

      return match && match[0].length > res.length ? match[0] : res;
    }, './');

    const tmpBase = path.resolve(path.dirname(file.path), dots);

    return `/${path.relative(tmpBase, file.path)}`;
  }

  return '';
}


function getRemoteStylesheetPath(fileObj, documentObj, filename) {
  let {hostname: styleHost, port: stylePort, pathname} = fileObj;
  let {hostname: docHost, port: docPort} = documentObj || {};

  if (filename) {
    pathname = path.join(path.dirname(pathname), path.basename(filename));
    fileObj.pathname = pathname;
  }

  if (`${styleHost}:${stylePort}` === `${docHost}:${docPort}`) {
    return pathname
  }

  return url.format(fileObj);
}

/**
 *
 * @param {Vinyl} document Optional reference document
 * @param {Vinyl} file the file we want to check
 * @param {object} options Critical options object
 * @returns {Promise<*>}
 */
async function getStylesheetPath(document, file, options = {}) {
  let {base} = options;

  // check remote
  if (file.remote) {
    return getRemoteStylesheetPath(file.urlObj, document.urlObj);
  }

  // generate path relative to docuent if stylesheet is referenced relative
  if (isRelative(file.path)) {
    return path.join(path.dirname(document.path), file.path);
  }

  if (base) {
    base = path.resolve(base);
    return `/${path.relative(base, file.path)}`;
  }

  // try to compute path based on document link tags with same name
  const stylesheet = document.stylesheets.find(href => {
    const {pathname} = url.parse(href);
    const name = path.basename(pathname);
    return name === path.basename(file.path);
  });

  if (stylesheet && isRelative(stylesheet) && document.path) {
    return path.join(path.dirname(document.path), stylesheet);
  } else if (stylesheet && isRemote(stylesheet)) {
    return getRemoteStylesheetPath(url.parse(stylesheet), document.urlObj);
  } else if (stylesheet) {
    return stylesheet;
  }

  // try to find stylesheet path based on document link tags
  const [unsafestylesheet] = document.stylesheets.sort((a) => isRemote(a) ? 1 : -1);
  if (unsafestylesheet && isRelative(unsafestylesheet) && document.path) {
    return path.join(path.dirname(document.path), path.join(path.dirname(unsafestylesheet), path.basename(file.path)));
  } else if (unsafestylesheet && isRemote(unsafestylesheet)) {
    return getRemoteStylesheetPath(url.parse(unsafestylesheet), document.urlObj, path.basename(file.path));
  } else if (stylesheet) {
    return stylesheet;
  }

  process.stderr.write(BASE_WARNING);
  if (document.path && file.path) {
    return path.join(path.dirname(document.path), path.basename(file.path));
  }

  return '';
}

/**
 * Get a list of possible asset paths
 * Guess this is rather expensive so this method should only be used if
 * there's no other possible way
 *
 * @param {Vinyl} document Html document
 * @param {string} file File path
 * @param {object} options options
 * @returns {Promise<array>}
 */
async function getAssetPaths(document, file, options = {}) {
  const {base, rebase = {}, assetPaths = []} = options;
  const {history = [], url = ''} = document;
  const {from, to} = rebase;
  const [docpath] = history;

  if (isVinyl(file)) {
    return [];
  }


  // remove double dots in the middle
  const normalized = path.join(file);
  // count directory hops
  const hops = normalized.split('/').reduce((cnt, part) => (part === '..') ? cnt+1 : cnt, 0);
  // also findup first real dir path
  const [first] = normalized.split('/').filter(p => p && p !== '..');

  // Make a list of possible paths
  const paths = [...new Set([
    base,
    url,
    docpath && path.dirname(docpath),
    ...assetPaths,
    to,
    from,
    base && docpath && path.join(base, path.dirname(docpath)),
    base && to && path.join(base, path.dirname(to)),
    base && from && path.join(base, path.dirname(from)),
  ])];

  // Filter non existant paths
  const filtered = await filterAsync(paths, async f => {
    if (!f) {
      return false;
    }

    return await fileExists(f);
  });

  // Findup first directory in search path and add to the list if available
  const all = await reduceAsync([...new Set(filtered)], async (result, cwd) => {
    const up = await findUp(first, {cwd});
    if (up) {
      const upDir = path.dirname(up);

      if (hops) {
        // Add additional directories based on dirHops
        const additional = path.relative(upDir, cwd).split('/').slice(0,hops);
        return [...result, upDir, path.join(upDir, ...additional)];
      } else {
        return [...result, upDir];
      }
    }

    return result;
  }, filtered);

  // return uniquq result
  return [...new Set(all)];
}

/**
 * Create vinyl object from filepath
 *
 * @param filepath
 * @param html
 * @param options
 * @returns {Promise<File>}
 */
async function vinylize({filepath, html}, options = {}) {
  const {rebase = {}} = options;
  let file = new Vinyl();
  file.cwd = '/';
  file.remote = false;

  if (html) {
    const {to} = rebase;
    file.contents = Buffer.from(html);
    file.path = to || '';
  } else if (filepath && isVinyl(filepath)) {
    return filepath;
  } else if (filepath && isRemote(filepath)) {
    file.remote = true;
    file.url = filepath;
    file.urlObj = url.parse(filepath);
    file.contents = await fetch(filepath, options);
    file.path = file.urlObj.pathname;
  } else if (filepath && fs.existsSync(filepath)) {
    file.path = filepath;
    file.contents = await fs.readFile(filepath);
  } else {
    throw new FileNotFoundError(filepath);
  }

  return file;
}

/**
 * Get stylesheet file object
 * @param {string} filepath Path/Url to css file
 * @param {object} options Critical options
 * @param {Vinyl} document Document vinyl object
 * @returns {Promise<Vinyl>}
 */
async function getStylesheet(document, filepath, options = {}) {
  const {rebase = {}} = options;

  const exists = await fileExists(filepath, options);

  if (!exists) {
    const searchPaths = await getAssetPaths(document, filepath, options);
    try {
      filepath = await resolve(filepath, searchPaths, options);

    } catch (error) {
      if (!isRemote(filepath) || options.strict) {
        throw error;
      }

      return new Vinyl();
    }
  }

  const file = await vinylize({filepath});

  // get stylesheet path. Keeps stylesheet url if it differs from document url
  const stylepath = await getStylesheetPath(document, file, options);

  // if the stylesheet path is an url we need to rebase all assets to that url
  if (isRemote(stylepath)) {
    file.contents = rebaseAssets(file.contents, rebase.from || stylepath, rebase.to || stylepath);

    // we can only rebase if we have either a valid document path to rebase to or we have an url
  } else if (document.path) {
    file.contents = rebaseAssets(file.contents, rebase.from || stylepath, rebase.to || document.path);
  }

  return file;
}

/**
 * Get css for document
 * @param document
 * @param options
 * @returns {Promise<string>}
 */
async function getCss(document, options = {}) {
  const {css} = options;
  let stylesheets = [];

  if (css) {
    const files = await glob(css, options);
    stylesheets = await mapAsync(files, async file => getStylesheet(document, file, options));
  } else {
    stylesheets = await mapAsync(document.stylesheets, async file => getStylesheet(document, file, options));
  }

  return stylesheets
    .filter(stylesheet => !stylesheet.isNull())
    .map(stylesheet => stylesheet.contents.toString())
    .join(os.EOL);
}

/**
 * Get document file object
 * @param {string} filepath Path/Url to html file
 * @param {object} options Critical options
 * @returns {Promise<Vinyl>}
 */
async function getDocument(filepath, options = {}) {
  const {rebase = {}, base} = options;

  if (!isRemote(filepath) && !fs.existsSync(filepath) && base) {
    filepath = path.join(base, filepath);
  }

  const document = await vinylize({filepath});
  document.stylesheets = await getStylesheetHrefs(document);
  document.path = rebase.to || await getDocumentPath(document, options);
  document.css = await getCss(document, options);

  // store document as we need a file or url for penthouse
  if (!document.url) {
    const file = tempy.file({extension: 'html'});
    await fs.writeFile(file, document.contents);

    document.url = `file://${file}`;
  }

  return document;
}

/**
 * Get document file object from raw html source
 * @param html
 * @param options
 * @returns {Promise<*>}
 */
async function getDocumentFromSource(html, options = {}) {
  const {rebase = {}} = options;
  const document = await vinylize({html});
  document.stylesheets = await getStylesheetHrefs(document);
  document.path = rebase.to || await getDocumentPath(document, options);
  document.css = await getCss(document, options);

  // store document as we need a file or url for penthouse
  if (!document.url) {
    const file = tempy.file({extension: 'html'});
    await fs.writeFile(file, document.contents);

    document.url = `file://${file}`;
  }


  return document
}


module.exports = {
  BASE_WARNING,
  normalizePath,
  isRemote,
  token,
  fileExists,
  resolve,
  joinPath,
  vinylize,
  getStylesheetHrefs,
  getAssets,
  getDocumentPath,
  getStylesheetPath,
  getStylesheet,
  getDocument,
  getDocumentFromSource,
  getCss,
};



